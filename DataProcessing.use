model DataProcessing
enum ValueType{Categorical, Float, DateTime, Int, Boolean}

class Dataset
	operations
	  removeColumn(c:Column)
end

class Job
end

abstract class Parameter
  attributes
    name:String
end

class ColumnParam < Parameter
  attributes
   exclude:Boolean
end

class Primitive < Parameter
end

class Bool < Primitive
	attributes
	 value:Boolean
end

class Float < Primitive
	attributes
	 value:Real
end

class Int < Primitive
	attributes
	 value:Integer
end

class Text < Primitive
	attributes
	 value:String
end

abstract class DataOperation
   attributes
     uri:String
   operations
	 make()
end

class GetDummyVariables < DataOperation
end

class RemoveColumns < DataOperation
end

class Smote < DataOperation
end

class Split < DataOperation
end

class Column
   attributes
     uri:Integer
	 name:String
	 type:ValueType
	 id:Boolean
	 target:Boolean
end	 
class Row
   attributes
      uri:Integer
end

class Data
   attributes
      value:String
end
	  
association DataRow between
	Data [0..1] role data
	Row [1] role row
end

association DataCol between
	Data [0..1] role data
	Column [1] role col
end

aggregation DSCol between
	Dataset [1]
	Column [1..*] role cols
end

aggregation DSRow between
	Dataset [1] 
	Row [1..*] role rows
end

aggregation DSData between
	Dataset [1] 
	Data [1..*] role data
end

aggregation JobDop between
	Job [1]
	DataOperation [1..*]
end

association ColumnParams between
    ColumnParam[1]
	Column [1]
end

aggregation DopParam between
	DataOperation [1]
	Parameter [1..*]
end

association DopInputDset between
	DataOperation [1] role opIn
	Dataset [1..*] role dataIn
end

association DopOutputDset between
	DataOperation [1] role opOut
	Dataset [1..*] role dataOut
end

constraints
context GetDummyVariables
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.dataset = self.dataIn->asSequence->at(1))
	inv pre_columnType: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.type = ValueType::Categorical)
	inv pre_columnId: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.id = false)
	inv pre_columnTarget: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.target = false)
	inv inv_makeCorrectOneHotZero: self.dataOut->asSequence->at(1).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1) )->forAll(
			d | self.dataOut->asSequence->at(1).data->select(
				d2 | self.dataOut->asSequence->at(1).cols->select(c | (self.dataOut->asSequence->at(1).data->select(d|d.col.uri=0)->collect(value)->asSet())->includes(c.name))->includes(d2.col) 
				and d2.row.uri= d.row.uri 
				and d2.col.name <> d.value)->collect(value)->forAll(v|v='0'))
	inv inv_makeCorrectOneHotOne: self.dataOut->asSequence->at(1).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1) )->forAll(
			d | self.dataOut->asSequence->at(1).data->select(d2 | d2.col.name = d.value and d2.row.uri = d.row.uri)->collect(value)->asSequence()->at(1) = '1')
	inv post_existsColumns: self.dataOut->asSequence->at(1).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.dataOut->asSequence->at(1).cols->select(c|c.name=d.value)->size()=1)
	inv post_colTypes: self.dataOut->asSequence->at(1).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.dataOut->asSequence->at(1).cols->select(c|c.name=d.value)->collect(type)->asSequence->at(1)=ValueType::Boolean)
	inv post_colId: self.dataOut->asSequence->at(1).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.dataOut->asSequence->at(1).cols->select(c|c.name=d.value)->collect(id)->asSequence->at(1)=false)
	inv post_colTarget: self.dataOut->asSequence->at(1).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.dataOut->asSequence->at(1).cols->select(c|c.name=d.value)->collect(target)->asSequence->at(1)=false)

context RemoveColumns
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.dataset = self.dataIn->asSequence->at(1))
	inv post_noColumnDset: self.dataOut->asSequence->at(1).cols->forAll(col|col.name<>self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.name)->asSequence()->at(1))

context Smote
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.dataIn->asSequence->at(1)
	inv pre_columnType: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.type = ValueType::Categorical)
	inv post_columnDset: self.dataOut->asSequence->at(1).cols.name->includes(self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.name)
	inv post_columnType: self.dataOut->asSequence->at(1).cols->select(
		c | c.name = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.name)->asSequence()->at(1).type = ValueType::Categorical
	inv inv_makeCorrectSmote: self.dataOut->asSequence->at(1).data->select(d|d.col.uri=  self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(
		column.uri)->asSequence()->at(1))->collect(value)->asSet()->forAll(
			v | self.dataOut->asSequence->at(1).data->select(d|d.col.uri=  self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(
				column.uri)->asSequence()->at(1) and d.value = v)->size() = self.dataOut->asSequence->at(1).data->select(d|d.col.uri=1 and d.value=self.dataOut->asSequence->at(1).data->select(
					d|d.col.uri=1)->collect(value)->asSequence()->at(1))->size())

context Split
	inv pre_sizeParam: self.parameter->select(p|p.oclIsTypeOf(Float) and p.name = 'size').oclAsType(Float)->collect(value)->asSequence()->at(1) < 1
	inv pre_stratifiedCol:
		if (self.parameter->select(p | p.oclIsTypeOf(Bool) and p.name='stratified').oclAsType(Bool)->collect(value)->asSequence()->at(1) = true)
		then
			self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->size()=1 and self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.dataset = self.dataIn->asSequence->at(1))
		else
			true
		endif
	inv inv_first_number_rows: self.dataOut->asSequence()->at(1).rows->size() = ((self.parameter->select(p | p.name = 'size' and p.oclIsTypeOf(Float)).oclAsType(Float)->collect(value)->asSequence()->at(1)) * self.dataIn.rows->size()).round()
	inv inv_second_number_rows: self.dataOut->asSequence()->at(2).rows->size() = (1 - (self.parameter->select(p | p.name = 'size' and p.oclIsTypeOf(Float)).oclAsType(Float)->collect(value)->asSequence()->at(1)) * self.dataIn.rows->size()).round()
	inv post_two_datasets: self.dataOut->size() = 2
		
			