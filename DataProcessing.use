model DataProcessing
enum ValueType{Categorical, Float, DateTime, Int, Boolean, String}
enum ModelMethodType{Train, Test}
enum ClassificationAlgorithmType{DecisionTree, SVM, LogisticRegression, RandomForest}
enum RegressionAlgorithmType{DecissionTreeRegresor, SVR, LinearRegression, RandomForestRegresor}
enum ClusteringAlgorithmType{KMeans, KModes, HiererchicalClustering}
enum SortType{ASC, DESC}
enum PrimitiveType{BoolPr, IntPr, FloatPr, StringPr}
enum ClosureType{openOpen, openClosed, closedOpen, closedClosed}


abstract class Parameter
  attributes
    name:String
end

class ColumnParam < Parameter
  attributes
   exclude:Boolean
end

class Primitive < Parameter
  attributes
	value:String
	type:PrimitiveType
end

class ModelMethod < Parameter
	attributes
	 method:ModelMethodType
end

class SortCriteria < Parameter
	attributes
	 sortType:SortType
end

class BinParam < Parameter
	attributes
		binValue:String
		leftMargin:Real
		rightMargin:Real
		closure:ClosureType
end

abstract class Operator < Parameter
end

abstract class BinaryOp < Operator
end

class LessOp < BinaryOp
end

class LessEqualOp < BinaryOp
end

class GreatherOp < BinaryOp
end

class GreatherEqualOp < BinaryOp
end

class EqualOp < BinaryOp
end

abstract class UnaryOp < Operator
end

class MissingOp < UnaryOp
end

class NotOP < UnaryOp
end

class FilterType < Parameter
end

class ColValue < FilterType
end

class RowNumber < FilterType
end

class MatchingType < Parameter
end

class MissingValues < MatchingType
end

class Range < MatchingType
end

class RangeInt < Range
	attributes
	 min:Integer
	 max:Integer
end

class RangeFloat < Range
	attributes
	 min:Real
	 max:Real
end

abstract class PortType
	attributes
	 uri:Integer
	 name:String
	 path:String
end

class Dataset < PortType
	attributes
	 sep:String
	 null_values: Set(String)
end

abstract class MLModel < PortType
end

class ClassificationModel < MLModel
	attributes
	 algorithm:ClassificationAlgorithmType
end

class RegressionModel < MLModel
	attributes
	 algorithm:RegressionAlgorithmType
end

class ClusteringModel < MLModel
	attributes
	 algorithm:ClusteringAlgorithmType
end

class DataVisualization < PortType
end
	 

abstract class DataProcessingElement
	attributes
		uri:String
end

class Job < DataProcessingElement
end

abstract class DataOperation < DataProcessingElement
   operations
	 make()
end

class GetDummyVariables < DataOperation
end

class RemoveColumns < DataOperation
end

class ImbalancedLearn < DataOperation
end

class Split < DataOperation
end

class StringToNumerical < DataOperation
end

class Binning < DataOperation
end

class Concatenate < DataOperation
end

class ConstantValueColumn < DataOperation
end

class ColumnRename < DataOperation
end

class NumberToString < DataOperation
end

class RowFilter < DataOperation
end

class RowSplitter < DataOperation
end

class Binarizer < DataOperation
end

class Sorter < DataOperation
end

class RuleBasedRowFilter < DataOperation
end

class Discretize < DataOperation
end

class RuleEngine < DataOperation
end

class Normalizer < DataOperation
end

class Column
   attributes
     uri:Integer
	 name:String
	 type:ValueType
	 id:Boolean
	 target:Boolean
end	 
class Row
   attributes
      uri:Integer
end

class Data
	attributes
		value:String
end
	  
association DataRow between
	Data [1] role data
	Row [1] role row
end

association DataCol between
	Data [1] role data
	Column [1] role col
end

association ColValueMatchingType between
	ColValue [1] 
	MatchingType [1]
end

association RowNumberMatchingType between
	RowNumber [1]
	RangeInt [1]
end

aggregation DSCol between
	Dataset [1]
	Column [1..*] role cols
end

aggregation DSRow between
	Dataset [1] 
	Row [1..*] role rows
end

aggregation DSData between
	Dataset [1] 
	Data [1..*] role data
end

aggregation JobDop between
	Job [1] role jobDop
	DataOperation [1..*] role dopJob
end

aggregation JobJob between
	Job[1]
	Job [0..*] role jobInput
end

aggregation  InputPort between
	DataProcessingElement [1] role dataProcessingInput
	PortType [1..*] role inputPort
end

aggregation  OutputPort between
	DataProcessingElement [1] role dataProcessingOutput
	PortType [1..*] role outputPort
end

aggregation LeftOperand between
	BinaryOp [1] role binaryOpLeftOp
	ColumnParam [1] role leftOperandBinary
end

aggregation RightOperand between
	BinaryOp [1] role binaryOpRightOp
	Primitive [1] role rightOperandBinary
end


aggregation BinaryPrimitive between
	BinaryOp [1] role binaryOpResult
	Primitive [1] role resultBinary
end

aggregation Operand between
	UnaryOp [1] role unaryOpLeftOp
	ColumnParam [1] role leftOperandUnary
end

aggregation UnaryPrimitive between
	UnaryOp [1] role unaryOpResult
	Primitive [1] role resultUnary
end

association ColumnParams between
    ColumnParam[1]
	Column [1]
end

aggregation DopParam between
	DataOperation [1]
	Parameter [1..*]
end



constraints

context GetDummyVariables
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1))
	inv pre_columnType: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.type = ValueType::Categorical)
	inv pre_columnId: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.id = false)
	inv pre_columnTarget: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.target = false)
	inv inv_makeCorrectOneHotZero: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1) )->forAll(
			d | self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
				d2 | self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(
					c | (self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(d|d.col.uri=(self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))
					)->collect(value)->asSet())->includes(c.name))->includes(d2.col) 
				and d2.row.uri= d.row.uri 
				and d2.col.name <> d.value)->collect(value)->forAll(v|v='0'))
	inv inv_makeCorrectOneHotOne: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1) )->forAll(
			d | self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(d2 | d2.col.name = d.value and d2.row.uri = d.row.uri)->collect(value)->asSequence()->at(1) = '1')
	inv post_existsColumns: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(c|c.name=d.value)->size()=1)
	inv post_colTypes: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(c|c.name=d.value)->collect(type)->asSequence->at(1)=ValueType::Boolean)
	inv post_colId: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(c|c.name=d.value)->collect(id)->asSequence->at(1)=false)
	inv post_colTarget: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d|d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.uri)->asSequence()->at(1))->forAll(
			d|self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(c|c.name=d.value)->collect(target)->asSequence->at(1)=false)

context RemoveColumns
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1))
	inv post_noColumnDset: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->forAll(col|col.name<>self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.name)->asSequence()->at(1))

context ImbalancedLearn
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv pre_columnType: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence()->at(1).column.type = ValueType::Categorical or 
						self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence()->at(1).column.type = ValueType::Boolean

	inv post_columnDset: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols.name->includes(self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.name)
	inv post_columnTypeCategorical: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(
		c | c.name = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(
			ColumnParam)->asSequence->at(1).column.name)->asSequence()->at(1).type = ValueType::Categorical
			or self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(
		c | c.name = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(
			ColumnParam)->asSequence->at(1).column.name)->asSequence()->at(1).type = ValueType::Boolean

	inv inv_makeCorrectImbalancedLearn: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(d|d.col.uri=  self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(
		ColumnParam)->collect(column.uri)->asSequence()->at(1))->collect(value)->asSet()->forAll(
			v | self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(d|d.col.uri=  self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(
				column.uri)->asSequence()->at(1) and d.value = v)->size() = self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(d|d.col.uri=  self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(
				column.uri)->asSequence()->at(1) and d.value <> v)->size())

context Split
	inv pre_sizeParam: self.parameter->select(p|p.oclIsTypeOf(Primitive) and p.name = 'size').oclAsType(Primitive)->select(p | p.type = PrimitiveType::FloatPr)->collect(value)->asSequence()->at(1).toReal() < 1
	inv pre_stratifiedCol:
		if (self.parameter->select(p | p.oclIsTypeOf(Primitive) and p.name='stratified').oclAsType(Primitive)->select(p | p.type = PrimitiveType::BoolPr)->collect(value)->asSequence()->at(1).toBoolean() = true)
		then
			self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->size()=1 and self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->forAll(cp | cp.column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1))
		else
			true
		endif
	inv inv_first_number_rows: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence()->at(1).oclAsType(Dataset).rows->size() = (
		(self.parameter->select(p | p.name = 'size' and p.oclIsTypeOf(Primitive)).oclAsType(Primitive)->collect(value)->asSequence()->at(1).toReal()) * self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(Dataset).rows->size()).round()
	inv inv_second_number_rows: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence()->at(2).oclAsType(Dataset).rows->size() = ( 
		(1 - (self.parameter->select(p | p.name = 'size' and p.oclIsTypeOf(Primitive)).oclAsType(Primitive)->collect(value)->asSequence()->at(1).toReal)) * 
		self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(Dataset).rows->size()
		).round()
	inv post_two_datasets: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->size() = 2

context StringToNumerical
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv pre_columnTypeString: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence()->at(1).column.type = ValueType::String
	inv post_columnDset: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols.name->includes(self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.name)
	inv post_columnTypeNumerical: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(
		c | c.name = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(
			ColumnParam)->asSequence->at(1).column.name)->asSequence()->at(1).type = ValueType::Int
			or self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(
		c | c.name = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(
			ColumnParam)->asSequence->at(1).column.name)->asSequence()->at(1).type = ValueType::Float
	inv inv_makeCorrectStringToNumber: self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri) = self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)

context Binning
	inv pre_columnsDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam))->forAll(cp | cp.oclAsType(ColumnParam).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1))
	inv pre_columnsTypeNumerical: self.parameter->select(p|p.oclIsTypeOf(ColumnParam))->forAll(cp | cp.oclAsType(ColumnParam).column.type = ValueType::Int or cp.oclAsType(ColumnParam).column.type = ValueType::Float)
	inv post_columnsTypeCategorical: self.parameter->select(p|p.oclIsTypeOf(ColumnParam))->forAll(cp | self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(
		c | c.uri = cp.oclAsType(ColumnParam).column.uri)->asSequence()->at(1).type = ValueType::Categorical)

context Concatenate
	inv pre_twoDatasets: self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->size() = 2
	inv post_oneDataset: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->size() = 1
	inv makeCorrectConcatenateRows: self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset).rows->size() = 
	self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence()->at(1).oclAsType(Dataset).rows->size() + self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence()->at(2).oclAsType(Dataset).rows->size()
	inv makeCorrectConcatenateCols: self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset).cols->asSequence() = 
	self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence()->at(1).oclAsType(Dataset).cols->union(self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence()->at(2).oclAsType(Dataset).cols)->asSequence()
	

context ConstantValueColumn
	inv pre_noColumnDataset: self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).cols->select(c | c.name = self.parameter->select(p | p.oclIsTypeOf(Primitive) and p.name = 'name').oclAsType(Primitive)->asSequence()->at(1).value)->size() = 0
	inv post_columnDataset: self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).cols->select(c | c.name = self.parameter->select(p | p.oclIsTypeOf(Primitive) and p.name = 'name').oclAsType(Primitive)->asSequence()->at(1).value)->size() = 1
	inv inv_makeCorrectCreation: self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).cols->select(c | c.name = self.parameter->select(p | p.oclIsTypeOf(Primitive) and p.name = 'name').oclAsType(Primitive)->asSequence()->at(1).value).data->collect(
		value)->forAll(v | v = (self.parameter->select(p | p.oclIsTypeOf(Primitive) and p.name = 'value').oclAsType(Primitive)->asSequence()->at(1).value))

context ColumnRename
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv post_newColumnDset: self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).cols->collect(name)->includes(self.parameter->select(p | p.name = 'newName' and p.oclIsTypeOf(Primitive))->asSequence()->at(1).name)
	inv post_noColumnDset: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->forAll(col|col.name<>self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->collect(column.name)->asSequence()->at(1))
	inv inv_makeCorrectRename: self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).cols->select(c | c.uri = self.parameter->select(p | p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(
		1).column.uri).data = self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).cols->select (c | c.name = self.parameter->select(p | p.name = 'newName' and p.oclIsTypeOf(Primitive))->asSequence()->at(1).name).data

context NumberToString
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv post_columnDset: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols.name->includes(self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.name)
	inv post_columnTypeString: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).cols->select(
		c | c.name = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(
			ColumnParam)->asSequence->at(1).column.name)->asSequence()->at(1).type = ValueType::String
	inv inv_makeCorrectNumberToString: self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri) = self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)

context Binarizer
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv post_transformValues: self.outputPort->select(op | op.oclIsTypeOf(Dataset))->asSequence->at(1).oclAsType(Dataset).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(v | v.toInteger() = 0 or v.toInteger() = 1)

context RowFilter
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv inv_makeCorrectFilter:
		if (self.parameter->select(p | p.oclIsTypeOf(FilterType))->size() = 1)
		then
			if (self.parameter->select(p | p.oclIsTypeOf(MatchingType))->size() = 1) then
				if (self.parameter->select(p | p.oclIsTypeOf(ColValue)).oclAsType(ColValue)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(RangeFloat)).oclAsType(RangeFloat)->asSequence->at(1).isDefined()) then
					self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(
							v | v.toReal() > self.parameter->select(p | p.oclIsTypeOf(RangeFloat)).oclAsType(RangeFloat)->asSequence()->at(1).min and 
							v.toReal() < self.parameter->select(p | p.oclIsTypeOf(RangeFloat)).oclAsType(RangeFloat)->asSequence()->at(1).max)
				else if (self.parameter->select(p | p.oclIsTypeOf(ColValue)).oclAsType(ColValue)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->size() = 1) then
					self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(
							v | v.toInteger() > self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).min and 
							v.toInteger() < self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).max)
				else if (self.parameter->select(p | p.oclIsTypeOf(ColValue)).oclAsType(ColValue)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(MissingValues)).oclAsType(MissingValues)->size() = 1) then
					self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(v | v.isDefined()
					and not self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).null_values->includes(v))
				else if (self.parameter->select(p | p.oclIsTypeOf(RowNumber)).oclAsType(RowNumber)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->size() = 1) then
					self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).rows->collect(uri)->asSequence()->forAll(
						u | u > self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).min and u < self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).max)
				else false endif endif endif endif
			else false endif
		else false endif



context RowSplitter
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv inv_makeCorrectFilter:
		if (self.parameter->select(p | p.oclIsTypeOf(FilterType))->size() = 1)
		then
			if (self.parameter->select(p | p.oclIsTypeOf(MatchingType))->size() = 1) then
				if (self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(2).data = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data) then
					if (self.parameter->select(p | p.oclIsTypeOf(ColValue)).oclAsType(ColValue)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(RangeFloat)).oclAsType(RangeFloat)->asSequence->at(1).isDefined()) then
						self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(
								v | v.toReal() > self.parameter->select(p | p.oclIsTypeOf(RangeFloat)).oclAsType(RangeFloat)->asSequence()->at(1).min and 
								v.toReal() < self.parameter->select(p | p.oclIsTypeOf(RangeFloat)).oclAsType(RangeFloat)->asSequence()->at(1).max)
					else if (self.parameter->select(p | p.oclIsTypeOf(ColValue)).oclAsType(ColValue)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->size() = 1) then
						self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(
								v | v.toInteger() > self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).min and 
								v.toInteger() < self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).max)
					else if (self.parameter->select(p | p.oclIsTypeOf(ColValue)).oclAsType(ColValue)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(MissingValues)).oclAsType(MissingValues)->size() = 1) then
						self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(v | v.isDefined())
					else if (self.parameter->select(p | p.oclIsTypeOf(RowNumber)).oclAsType(RowNumber)->size() = 1 and self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->size() = 1) then
						self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).rows->collect(uri)->asSequence()->forAll(
							u | u > self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).min and u < self.parameter->select(p | p.oclIsTypeOf(RangeInt)).oclAsType(RangeInt)->asSequence()->at(1).max)
					else false endif endif endif endif
				else false endif
			else false endif
		else false endif

context Sorter
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv pre_define_sortType: self.parameter->select(p|p.oclIsTypeOf(SortCriteria))->size() = 1
	inv post_makeCorrectSort:
		let sortData = self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value) in
			if self.parameter->select(p | p.oclIsTypeOf(SortCriteria)).oclAsType(SortCriteria)->collect(sortType)->asSequence()->at(1) = SortType::ASC then
				let sortDataSeq = sortData->asSequence() in
					sortData->iterate(elem; index : Integer = 1 | if elem = sortDataSeq->at(index) then index + 1 else index endif) = sortData->size()
			else
				let sortDataSeq = sortData->asSequence()->reverse() in
					sortData->iterate(elem; index : Integer = 1 | if elem = sortDataSeq->at(index) then index + 1 else index endif) = sortData->size()
			endif

context RuleBasedRowFilter
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv pre_define_operator: self.parameter->select(p | p.oclIsTypeOf(Operator))->size() > 1
	inv post_makeCorrectFilter:
		let filterValues = self.parameter->select(p | p.oclIsTypeOf(Primitive)).oclAsType(Primitive)->collect(value) in
			if self.parameter->select(p | p.oclIsTypeOf(Operator))->asSequence()->at(1).oclIsTypeOf(EqualOp) then
				self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(
					Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(
						p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(v | filterValues->includes(v))
			else
				false
			endif
		
context Discretize
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv pre_derivedField: self.parameter->select(p | p.oclIsTypeOf(Primitive) and p.name = 'derivedField')->size() = 1
	inv pre_makeCorrectBin: self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->forAll
		(
			d | let binName = self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select( 
				d2 | d2.col.name = self.parameter->select(p | p.oclIsTypeOf(Primitive) and p.name = 'derivedField').oclAsType(Primitive)->asSequence()->at(1).value
				and d2.row.uri = d.row.uri)->asSequence()->at(1).value in
				let bin = self.parameter->select(p | p.oclIsTypeOf(BinParam)).oclAsType(BinParam)->select(b | b.binValue = binName)->asSequence()->at(1) in
					if bin.closure = ClosureType::closedClosed then
						d.value.toReal() >= bin.leftMargin and d.value.toReal() <= bin.rightMargin
						else if bin.closure = ClosureType::closedOpen then
							d.value.toReal() >= bin.leftMargin and d.value.toReal() < bin.rightMargin
							else if bin.closure = ClosureType::openClosed then
								d.value.toReal() > bin.leftMargin and d.value.toReal() <= bin.rightMargin
								else if bin.closure = ClosureType::openOpen then
									d.value.toReal() > bin.leftMargin and d.value.toReal() < bin.rightMargin
								else false endif
							endif
						endif
					endif
		)

context RuleEngine
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv pre_define_operator: self.parameter->select(p | p.oclIsTypeOf(Operator))->size() > 1
	inv post_makeCorrectEngine:
		if self.parameter->select(p | p.oclIsTypeOf(Operator))->asSequence()->at(1).oclIsTypeOf(MissingOp) then
			let imputeValue = self.parameter->select(p | p.oclIsTypeOf(Primitive)).oclAsType(Primitive)->asSequence()->at(1).value in
				self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(
					Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(
						p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri and (d.value.isUndefined() or self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(
						Dataset)->asSequence()->at(1).null_values->includes(d.value)))->collect(row.uri)->forAll(
							uri | self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(
							Dataset)->asSequence()->at(1).data->select(d2| d2.col.uri = self.parameter->select(
							p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->select(d2 | d2.row.uri = uri)->asSequence()->at(1).value = imputeValue
						)
		else 
			if self.parameter->select(p | p.oclIsTypeOf(Operator))->asSequence()->at(1).oclIsTypeOf(EqualOp) then
				let rightOpValue = self.parameter->select(p | p.oclIsTypeOf(Operator))->asSequence()->at(1).oclAsType(BinaryOp).rightOperandBinary.value in
					let binaryOpResult = self.parameter->select(p | p.oclIsTypeOf(Operator))->asSequence()->at(1).oclAsType(BinaryOp).resultBinary.value in
						self.inputPort->select(ip | ip.oclIsTypeOf(Dataset)).oclAsType(
						Dataset)->asSequence()->at(1).data->select(d | d.col.uri = self.parameter->select(
						p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri and d.value = rightOpValue)->collect(row.uri)->forAll(
							uri | self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(
							Dataset)->asSequence()->at(1).data->select(d2| d2.col.uri = self.parameter->select(
							p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->select(d2 | d2.row.uri = uri)->asSequence()->at(1).value = binaryOpResult
						)
			else 
				false
			endif
		endif

context Normalizer
	inv pre_columnDset: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.dataset = self.inputPort->select(ip | ip.oclIsTypeOf(Dataset))->asSequence->at(1)
	inv pre_columnsTypeNumerical: self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence()->at(1).column.type = ValueType::Int or self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence()->at(1).column.type = ValueType::Float		
	inv post_makeCorrectNormalizer: self.outputPort->select(op | op.oclIsTypeOf(Dataset)).oclAsType(Dataset)->asSequence()->at(1).data->select(
		d | d.col.uri = self.parameter->select(p|p.oclIsTypeOf(ColumnParam)).oclAsType(ColumnParam)->asSequence->at(1).column.uri)->collect(value)->forAll(v | v.toReal() >= 0 and v.toReal()<=1)